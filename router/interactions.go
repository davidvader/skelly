package router

import (
	"net/http"
	"os"

	"github.com/davidvader/skelly/skelly"
	"github.com/davidvader/skelly/util"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"github.com/slack-go/slack"
)

// interactionsHandler represents the API handler for handling slack interactions
// interactions are events generated by a user interacting with a button or attachment item
func interactionsHandler(c *gin.Context) {

	// extract the request from the gin context
	r := c.Request

	// retrieve the slack secrets from the environment
	sSecret := os.Getenv("SKELLY_SIGNING_SECRET")

	// set up signing secret verification
	s, err := slack.NewSecretsVerifier(r.Header, sSecret)
	if err != nil {
		err = errors.Wrap(err, "could not create signing secret verifier")
		logrus.Error(err)
		c.AbortWithStatusJSON(http.StatusBadRequest, err.Error())
		return
	}

	// read request body
	b, err := c.GetRawData()
	if err != nil {
		err = errors.Wrap(err, "could not read body from request")
		logrus.Error(err)
		c.AbortWithStatusJSON(http.StatusBadRequest, err.Error())
		return
	}
	s.Write(b)

	// verify signing secret
	err = s.Ensure()
	if err != nil {
		err = errors.Wrap(err, "could not ensure signing secret")
		logrus.Error(err)
		c.AbortWithStatusJSON(http.StatusBadRequest, err.Error())
		return
	}

	// parse the request payload parameter
	body, err := util.ParsePayload(b)
	if err != nil {
		err = errors.Wrap(err, "could not parse payload")
		logrus.Error(err)
		c.AbortWithStatusJSON(http.StatusBadRequest, err.Error())
		return
	}

	// Handle the interaction
	err = skelly.HandleInteraction(c, body)
	if err != nil {
		err = errors.Wrap(err, "could not handle interaction")
		logrus.Error(err)
		c.AbortWithStatusJSON(http.StatusInternalServerError, err.Error())
		return
	}

}
